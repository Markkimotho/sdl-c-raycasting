
/* ===== FILE: ./index.html ===== */

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Retro Raycasting Engine</title>
  <style>
    body {
      width: 1000px;
      font-family: 'Courier New', monospace;
      background-color: #000000;
      color: #ffffff;
      text-align: center;
      margin: 0 auto;
      padding: 0;
    }
    
    header {
      background-color: #000000;
      padding: 2i0px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    header img {
      width: 200px;
    }
    
    h1 {
      font-size: 40px;
      margin-top: 50px;
      letter-spacing: 8px;
      text-transform: uppercase;
    }
    
    button {
      cursor: pointer;
      background-color: #d01919;
      color: #ffffff;
      font-size: 24px;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: background-color 0.3s ease;
      font-family: 'Courier New', monospace;
    }

    button:hover {
      background-color: #b00b0b;
    }
    
    p {
      font-size: 28px;
      margin-bottom: 80px;
    }
    
    #video-container {
      max-width: 800px;
      margin: 0 auto;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
      margin-bottom: 80px;
    }
    
    .feature {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      margin-bottom: 80px;
    }
    
    .feature img {
      max-width: 400px;
      margin-bottom: 20px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    
    nav a {
      color: aqua;
      margin: 10px;
    }
    
    .about {
      max-width: 600px;
      margin: 0 auto;
      margin-bottom: 80px;
    }
    
    .about p {
      font-size: 24px;
      margin-bottom: 20px;
    }
    
    .about a {
      color: aqua;
      text-decoration: underline;
    }
    
    ul {
      display: flex;
      justify-content: center;
      align-items: center;
      list-style-type: none;
    }
    
    li a {
      margin-left: 20px;
      color: aqua;
    }

    footer {
      font-size: 14px;
      margin-top: 50px;
    }
  </style>
</head>
<body>
  <!-- Intro Section -->
  <header>
    <img src="assets/retro-computer-desk-arrangement.jpg" alt="Cover Image" width="800">
    <figcaption> Image by <a href="https://www.freepik.com/free-photo/retro-computer-desk-arrangement_37350452.htm#from_view=detail_serie">Freepik</a></figcaption>
    
    <h1>Retro Raycasting Engine</h1>
    <p>Raycasting engine built in C and SDL2</p>
    <nav>
      <a href="#features">Features</a>
      <a href="#about">About</a>
    </nav>
    <a href="https://github.com/Markkimotho/sdl-c-raycasting" target="_blank" rel="noopener noreferrer">
      <br>
      <button>Try It Out</button>
    </a>
  </header>
  
  <!-- Video Container -->
  <div id="video-container">
    <iframe width="800" height="350" src="https://www.youtube.com/embed/hvgugXd_9Qw" frameborder="0" allowfullscreen></iframe>
  </div>
  
  <!-- Feature Section -->
  <section id="features">
    <div class="feature">
      <h2>Features<h2>
      <img src="assets/maze.png" alt="Feature 1" width="400">
      <h2>Realistic Rendering</h2>
      <p>A Stunning and Realistic 3D environment is created using raycasting techniques.</p>
    </div>
    <div class="feature">
      <img src="assets/Peek 2.gif" alt="Feature 2" width="400">
      <h2>Collision Handling</h2>
      <p>Just like a person can't walk through walls in real life, the player cannot go through walls.</p>
    </div>
    <div class="feature">
      <img src="assets/map.png" alt="Feature 3" width="400">
      <h2>Mapping</h2>
      <p>A map outline of the maze is implemented that acts as a guide for the player (so the player is not completely.</p>
    </div>
    <div class="feature">
      <img src="assets/Peek.gif" alt="Feature 4" width="400">
      <h2>Efficient Performance</h2>
      <p>Optimized algorithms ensure smooth and efficient rendering and movement even on lower-end systems.</p>
    </div>
    <div class="feature">
      <img src="assets/textures_maze.png" alt="Feature 1" width="400">
      <h2>Wall Texturing</h2>
      <p>The walls of the maze are coated with imported textures to create some illusion of realism.</p>
    </div>
  </section>
  
  <!-- About Section -->
  <section id="about">
    <div class="about">
      <h2>About</h2>
      <p>Hi, I'm Mark Tinega, the developer behind the Retro Raycasting Engine. This project was inspired by my fascination with the classic first-person shooter games of the past, and my desire to understand the inner workings of their graphics engines.</p>
      <p>I used this as an opportunity to work on my C programming skills coupled with some math.</p>
      <p>You can find the complete source code on <a href="https://github.com/Markkimotho/sdl-c-raycasting" target="_blank" rel="noopener noreferrer">GitHub</a>. You are open to contribute and send me recommendations on how I can improve this engine.</p>
      <p>This is a work in progress, and more features and improvements will be added over time.</p>
    </div>
    <div class="team-members">
      <footer>
        <article>&copy; Mark Tinega</article>
      </footer>
      <ul>
        <li><a href="https://www.linkedin.com/in/mark-tinega/" target="_blank" rel="noopener noreferrer">LinkedIn</a></li>
        <li><a href="https://github.com/Markkimotho" target="_blank" rel="noopener noreferrer">GitHub</a></li>
        <li><a href="https://ktinega.substack.com/" target="_blank" rel="noopener noreferrer">Substack</a></li>
      </ul>
    </div>
  </section>
</body>
</html>

/* ===== FILE: ./Makefile ===== */

CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -Iheaders $(shell pkg-config --cflags sdl2 SDL2_image)
LDFLAGS = $(shell pkg-config --libs sdl2 SDL2_image) -lm

SRCS = src/main.c src/init.c src/textures.c
OBJS = $(SRCS:.c=.o)
TARGET = game

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CC) $(OBJS) -o $(TARGET) $(LDFLAGS)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

run: $(TARGET)
	./$(TARGET)

clean:
	rm -f $(OBJS) $(TARGET)

.PHONY: all run clean

/* ===== FILE: ./headers/global.h ===== */

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#include "structures.h"

#define WINDOW_WIDTH 1480
#define WINDOW_HEIGHT 820
#define MAP_WIDTH 16
#define MAP_HEIGHT 16

/* map is [row][col] => map[y][x] */
static const int map[MAP_HEIGHT][MAP_WIDTH] = {
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,0,1},
    {1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1},
    {1,0,0,0,1,1,1,0,1,1,1,0,1,0,0,1},
    {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};

extern int screenBuffer[WINDOW_WIDTH][WINDOW_HEIGHT]; /* used only for software draw fallback */

void drawMap(Instance *instance, Player *player);
void castRays(Instance *instance, Player *player);
void drawScreen(Instance *instance, Player *player);
void movePlayer(Player *player, float deltaTime);
void rotatePlayer(Player *player, float deltaTime);

#endif /* _GLOBAL_H_ */

/* ===== FILE: ./headers/structures.h ===== */

#ifndef _STRUCTURES_H_
#define _STRUCTURES_H_

#include <SDL2/SDL.h>

typedef struct Player {
    float x;
    float y;
    float dirX;
    float dirY;
    float planeX;
    float planeY;
} Player;

typedef struct Instance {
    SDL_Window *window;
    SDL_Renderer *renderer;
    SDL_Texture *wallTexture;
} Instance;

#endif /* _STRUCTURES_H_ */

/* ===== FILE: ./src/init.c ===== */

#include "SDL2/SDL.h"
#include "SDL2/SDL_image.h"
#include <stdio.h>
#include "../headers/structures.h"
#include "../headers/global.h"

int initializeSDL(Instance *instance)
{
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0) {
        fprintf(stderr, "SDL_Init failed: %s\n", SDL_GetError());
        return -1;
    }

    int imgFlags = IMG_INIT_PNG;
    if (!(IMG_Init(imgFlags) & imgFlags)) {
        fprintf(stderr, "IMG_Init failed: %s\n", IMG_GetError());
        SDL_Quit();
        return -1;
    }

    instance->window = SDL_CreateWindow("Raycasting Engine",
                        SDL_WINDOWPOS_CENTERED,
                        SDL_WINDOWPOS_CENTERED,
                        WINDOW_WIDTH,
                        WINDOW_HEIGHT,
                        0);
    if (!instance->window) {
        fprintf(stderr, "SDL_CreateWindow failed: %s\n", SDL_GetError());
        IMG_Quit();
        SDL_Quit();
        return -1;
    }

    instance->renderer = SDL_CreateRenderer(instance->window, -1, SDL_RENDERER_ACCELERATED);
    if (!instance->renderer) {
        fprintf(stderr, "SDL_CreateRenderer failed: %s\n", SDL_GetError());
        SDL_DestroyWindow(instance->window);
        IMG_Quit();
        SDL_Quit();
        return -1;
    }

    instance->wallTexture = NULL;
    return 0;
}

void cleanupSDL(Instance *instance)
{
    if (instance->wallTexture) {
        SDL_DestroyTexture(instance->wallTexture);
        instance->wallTexture = NULL;
    }
    if (instance->renderer) SDL_DestroyRenderer(instance->renderer);
    if (instance->window) SDL_DestroyWindow(instance->window);
    IMG_Quit();
    SDL_Quit();
}

/* ===== FILE: ./src/textures.c ===== */

#include "SDL2/SDL.h"
#include "SDL2/SDL_image.h"
#include <stdio.h>
#include "../headers/structures.h"

int loadTextures(Instance *instance)
{
    SDL_Surface *surf = IMG_Load("assets/colorstone.png");
    if (!surf) {
        fprintf(stderr, "IMG_Load failed: %s\n", IMG_GetError());
        return -1;
    }
    instance->wallTexture = SDL_CreateTextureFromSurface(instance->renderer, surf);
    SDL_FreeSurface(surf);
    if (!instance->wallTexture) {
        fprintf(stderr, "SDL_CreateTextureFromSurface failed: %s\n", SDL_GetError());
        return -1;
    }
    return 0;
}

void destroyTextures(Instance *instance)
{
    if (instance->wallTexture) {
        SDL_DestroyTexture(instance->wallTexture);
        instance->wallTexture = NULL;
    }
}

/* ===== FILE: ./src/main.c ===== */

#include <stdio.h>
#include <math.h>
#include <time.h>
#include "SDL2/SDL.h"
#include "../headers/structures.h"
#include "../headers/global.h"
#include "../src/init.c"     /* for small project, include C or declare prototypes */
#include "../src/textures.c" /* same note: you can prefer proper headers later */

int screenBuffer[WINDOW_WIDTH][WINDOW_HEIGHT]; /* not used for textured rendering but kept for legacy */

void castRays(Instance *instance, Player *player)
{
    for (int x = 0; x < WINDOW_WIDTH; x++) {
        float cameraX = 2 * x / (float)WINDOW_WIDTH - 1;
        float rayDirX = player->dirX + player->planeX * cameraX;
        float rayDirY = player->dirY + player->planeY * cameraX;

        int mapX = (int)player->x;
        int mapY = (int)player->y;

        float sideDistX, sideDistY;
        float deltaDistX = fabsf(1.0f / rayDirX);
        float deltaDistY = fabsf(1.0f / rayDirY);
        float perpWallDist;

        int stepX, stepY;
        int hit = 0, side = 0;

        if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (player->x - mapX) * deltaDistX;
        } else {
            stepX = 1;
            sideDistX = (mapX + 1.0f - player->x) * deltaDistX;
        }

        if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (player->y - mapY) * deltaDistY;
        } else {
            stepY = 1;
            sideDistY = (mapY + 1.0f - player->y) * deltaDistY;
        }

        while (!hit) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }

            /* careful: map is [row=y][col=x] */
            if (map[mapY][mapX] > 0) hit = 1;

            /* safety guard (avoid infinite loops) */
            if (mapX < 0 || mapX >= MAP_WIDTH || mapY < 0 || mapY >= MAP_HEIGHT) {
                hit = 1;
                break;
            }
        }

        if (side == 0)
            perpWallDist = (mapX - player->x + (1 - stepX) / 2.0f) / rayDirX;
        else
            perpWallDist = (mapY - player->y + (1 - stepY) / 2.0f) / rayDirY;

        if (perpWallDist <= 0.0f) perpWallDist = 0.0001f;

        int lineHeight = (int)(WINDOW_HEIGHT / perpWallDist);
        int drawStart = -lineHeight / 2 + WINDOW_HEIGHT / 2;
        if (drawStart < 0) drawStart = 0;
        int drawEnd = lineHeight / 2 + WINDOW_HEIGHT / 2;
        if (drawEnd >= WINDOW_HEIGHT) drawEnd = WINDOW_HEIGHT - 1;

        /* textured walls */
        int texW, texH;
        SDL_QueryTexture(instance->wallTexture, NULL, NULL, &texW, &texH);

        float wallX;
        if (side == 0)
            wallX = player->y + perpWallDist * rayDirY;
        else
            wallX = player->x + perpWallDist * rayDirX;
        wallX -= floorf(wallX);

        int texX = (int)(wallX * (float)texW);
        if (side == 0 && rayDirX > 0) texX = texW - texX - 1;
        if (side == 1 && rayDirY < 0) texX = texW - texX - 1;

        SDL_Rect dst = { x, drawStart, 1, drawEnd - drawStart + 1 };
        SDL_Rect src = { texX, 0, 1, texH };

        SDL_RenderCopy(instance->renderer, instance->wallTexture, &src, &dst);
    }
}

void drawMap(Instance *instance, Player *player)
{
    int miniMapSize = WINDOW_WIDTH / 6;
    int miniMapScale = miniMapSize / MAP_WIDTH;

    for (int y = 0; y < MAP_HEIGHT; y++) {
        for (int x = 0; x < MAP_WIDTH; x++) {
            SDL_Rect r = {
                WINDOW_WIDTH - miniMapSize + x * miniMapScale,
                y * miniMapScale,
                miniMapScale,
                miniMapScale
            };
            if (map[y][x] == 1) {
                SDL_SetRenderDrawColor(instance->renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(instance->renderer, &r);
            } else {
                SDL_SetRenderDrawColor(instance->renderer, 0, 0, 0, 255);
                SDL_RenderFillRect(instance->renderer, &r);
            }
        }
    }

    SDL_Rect pr = {
        WINDOW_WIDTH - miniMapSize + (int)(player->x * miniMapScale) - 2,
        (int)(player->y * miniMapScale) - 2,
        4, 4
    };
    SDL_SetRenderDrawColor(instance->renderer, 255, 0, 0, 255);
    SDL_RenderFillRect(instance->renderer, &pr);
}

void drawScreen(Instance *instance, Player *player)
{
    /* ceiling */
    SDL_SetRenderDrawColor(instance->renderer, 135, 206, 235, 255);
    SDL_Rect ceiling = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT / 2};
    SDL_RenderFillRect(instance->renderer, &ceiling);

    /* floor */
    SDL_SetRenderDrawColor(instance->renderer, 169, 169, 169, 255);
    SDL_Rect floor = {0, WINDOW_HEIGHT / 2, WINDOW_WIDTH, WINDOW_HEIGHT / 2};
    SDL_RenderFillRect(instance->renderer, &floor);

    castRays(instance, player);
    drawMap(instance, player);

    SDL_RenderPresent(instance->renderer);
}

void movePlayer(Player *player, float deltaTime)
{
    const float moveSpeed = deltaTime * 5.0f;
    const Uint8 *keyboardState = SDL_GetKeyboardState(NULL);

    float newX = player->x;
    float newY = player->y;

    if (keyboardState[SDL_SCANCODE_UP] || keyboardState[SDL_SCANCODE_W]) {
        newX += player->dirX * moveSpeed;
        newY += player->dirY * moveSpeed;
    }
    if (keyboardState[SDL_SCANCODE_DOWN] || keyboardState[SDL_SCANCODE_S]) {
        newX -= player->dirX * moveSpeed;
        newY -= player->dirY * moveSpeed;
    }

    int mapX = (int)newX;
    int mapY = (int)newY;

    if (map[mapY][mapX] == 0) {
        player->x = newX;
        player->y = newY;
    } else {
        if (map[(int)newY][mapX] == 0) player->y = newY;
        if (map[mapY][(int)newX] == 0) player->x = newX;
    }
}

void rotatePlayer(Player *player, float deltaTime)
{
    const float rotSpeed = deltaTime * 3.0f;
    const Uint8 *keyboardState = SDL_GetKeyboardState(NULL);

    if (keyboardState[SDL_SCANCODE_LEFT] || keyboardState[SDL_SCANCODE_A]) {
        float oldDirX = player->dirX;
        player->dirX = player->dirX * cosf(rotSpeed) - player->dirY * sinf(rotSpeed);
        player->dirY = oldDirX * sinf(rotSpeed) + player->dirY * cosf(rotSpeed);
        float oldPlaneX = player->planeX;
        player->planeX = player->planeX * cosf(rotSpeed) - player->planeY * sinf(rotSpeed);
        player->planeY = oldPlaneX * sinf(rotSpeed) + player->planeY * cosf(rotSpeed);
    }

    if (keyboardState[SDL_SCANCODE_RIGHT] || keyboardState[SDL_SCANCODE_D]) {
        float oldDirX = player->dirX;
        player->dirX = player->dirX * cosf(-rotSpeed) - player->dirY * sinf(-rotSpeed);
        player->dirY = oldDirX * sinf(-rotSpeed) + player->dirY * cosf(-rotSpeed);
        float oldPlaneX = player->planeX;
        player->planeX = player->planeX * cosf(-rotSpeed) - player->planeY * sinf(-rotSpeed);
        player->planeY = oldPlaneX * sinf(-rotSpeed) + player->planeY * cosf(-rotSpeed);
    }
}

int main(int argc, char **argv)
{
    Instance instance;
    Player player;

    if (initializeSDL(&instance) != 0) {
        return 1;
    }

    if (loadTextures(&instance) != 0) {
        cleanupSDL(&instance);
        return 1;
    }

    /* starting player */
    player.x = 3.5f;
    player.y = 3.5f;
    player.dirX = -1.0f;
    player.dirY = 0.0f;
    player.planeX = 0.0f;
    player.planeY = 0.66f;

    SDL_Event event;
    int quit = 0;
    Uint32 last = SDL_GetTicks();

    while (!quit) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) quit = 1;
            else if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_ESCAPE) quit = 1;
        }

        Uint32 now = SDL_GetTicks();
        float deltaTime = (now - last) / 1000.0f;
        if (deltaTime > 0.05f) deltaTime = 0.05f; /* clamp */
        last = now;

        movePlayer(&player, deltaTime);
        rotatePlayer(&player, deltaTime);

        drawScreen(&instance, &player);

        /* small delay to avoid pegging CPU */
        SDL_Delay(1);
    }

    destroyTextures(&instance);
    cleanupSDL(&instance);
    return 0;
}
